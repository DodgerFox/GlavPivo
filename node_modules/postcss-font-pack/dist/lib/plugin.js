'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _ = require('lodash');
var plugin = 'postcss-font-pack';
var errorContext = { plugin: plugin };
var errorPrefix = '[' + plugin + ']';
var sizeLineHeightPattern = /^\S+(?:\/\S+)?$/;
var directivePattern = new RegExp('^' + plugin + ': ([a-z-]+)$');
exports['default'] = _postcss2['default'].plugin('postcss-font-pack', function (options) {
    return function (root) {
        if (!options) {
            throw new Error(errorPrefix + ' missing required configuration');
        }
        var packs = options.packs;
        if (!packs) {
            throw new Error(errorPrefix + ' missing required option: packs');
        }
        if (!Object.keys(packs).length) {
            throw new Error(errorPrefix + ' packs option has no keys');
        }
        var lookup = buildLookupTable(packs);
        var zonesToIgnore = findZonesToIgnore(root);
        function isWithinIgnoreRange(decl) {
            if (zonesToIgnore.nexts.length && isPositionAfterOther(decl.source.start, zonesToIgnore.nexts[0])) {
                zonesToIgnore.nexts.shift();
                return true;
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = zonesToIgnore.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var range = _step.value;

                    if (isPositionAfterOther(decl.source.start, range.start) && isPositionAfterOther(range.end, decl.source.end)) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return false;
            function isPositionAfterOther(position, other) {
                if (position.line < other.line) {
                    return false;
                }
                if (position.line > other.line) {
                    return true;
                }
                return position.column >= other.column;
            }
        }
        root.walkRules(function (rule) {
            var props = {};
            var filteredPacks = [];
            var fontDeclarationCount = 0;
            var isSizeProvided = false;
            function resolveDeclaration(decl) {
                if (isWithinIgnoreRange(decl)) {
                    return;
                }
                function validatePackFound() {
                    if (!filteredPacks || !filteredPacks.length) {
                        throw decl.error('pack not found', errorContext);
                    }
                }
                if (decl.prop === 'font') {
                    var values = _postcss2['default'].list.space(decl.value);
                    fontDeclarationCount += values.length;
                    var family = values.pop();
                    var sizeLineHeight = values.pop();
                    props.font = { family: family, sizeLineHeight: sizeLineHeight, values: values };
                    if (_.isUndefined(family) || _.isUndefined(sizeLineHeight) || !sizeLineHeightPattern.test(sizeLineHeight)) {
                        throw decl.error('font property requires size and family', errorContext);
                    }
                    isSizeProvided = true;
                    filteredPacks = lookup[family];
                    values.forEach(function (val) {
                        filteredPacks = _.filter(filteredPacks, function (o) {
                            var prop = o['reverse:' + val];
                            if (_.isUndefined(prop)) {
                                return false;
                            }
                            props.font[prop] = val;
                            return true;
                        });
                    });
                    delete props.font.values;
                    validatePackFound();
                } else {
                    (function () {
                        fontDeclarationCount++;
                        var prop = decl.prop.substr(5);
                        if (prop === 'family') {
                            filteredPacks = lookup[decl.value];
                        } else {
                            filteredPacks = _.filter(filteredPacks, function (o) {
                                return o.hasOwnProperty(prop + ':' + decl.value);
                            });
                        }
                        validatePackFound();
                        props[prop] = decl.value;
                    })();
                }
            }
            rule.walkDecls(/^font(-family)?$/, resolveDeclaration);
            rule.walkDecls(/^font-(weight|style|variant|stretch)$/, resolveDeclaration);
            rule.walkDecls('font-size', function (decl) {
                if (isWithinIgnoreRange(decl)) {
                    return;
                }
                isSizeProvided = true;
                if (++fontDeclarationCount === 1) {
                    throw new Error(errorPrefix + ' font-size missing required family');
                }
            });
            if (fontDeclarationCount === 0) {
                return;
            }
            if (options.requireSize && !isSizeProvided) {
                throw new Error(errorPrefix + ' missing required font-size');
            }
            filteredPacks = _.reject(filteredPacks, function (p2) {
                var isMatch = true;
                _.forEach(Object.keys(p2), function (prop) {
                    if (_.startsWith(prop, 'reverse:')) {
                        return true;
                    }

                    var _prop$split = prop.split(':');

                    var _prop$split2 = _slicedToArray(_prop$split, 2);

                    var packProp = _prop$split2[0];
                    var packValue = _prop$split2[1];

                    var propValue = props[packProp];
                    if (_.isUndefined(propValue) && props.font) {
                        propValue = props.font[packProp];
                    }
                    if (packValue !== propValue) {
                        isMatch = false;
                        return false;
                    }
                    return true;
                });
                return !isMatch;
            });
            // ReSharper disable once QualifiedExpressionIsNull
            if (filteredPacks.length > 1) {
                throw new Error(errorPrefix + ' more than one pack found');
            }
            if (filteredPacks.length === 0) {
                throw new Error(errorPrefix + ' pack not found');
            }
            // passes validation
            var pack = filteredPacks[0];
            var font = props.font;
            if (font) {
                rule.walkDecls('font', function (decl) {
                    var sizeFamily = [font.sizeLineHeight, pack['family:' + font.family]];
                    delete font.sizeLineHeight;
                    delete font.family;
                    decl.value = _.union(Object.keys(font).map(function (prop) {
                        return pack[prop + ':' + font[prop]];
                    }), sizeFamily).join(' ');
                });
                delete props.font;
            }
            Object.keys(props).forEach(function (prop) {
                rule.walkDecls('font-' + prop, function (decl) {
                    decl.value = pack[prop + ':' + decl.value];
                });
            });
        });
    };
});

function buildLookupTable(packs) {
    var lookup = {};
    Object.keys(packs).forEach(function (slug) {
        var pack = packs[slug];
        if (!pack.family) {
            throw new Error(errorPrefix + ' missing required pack.family');
        }
        if (!pack.family.length) {
            throw new Error(errorPrefix + ' pack.family is empty');
        }
        var family = _defineProperty({}, 'family:' + slug, pack.family.join(', '));
        if (!pack.propGroups || !pack.propGroups.length) {
            lookup[slug] = [family];
            return;
        }
        lookup[slug] = pack.propGroups.map(function (prop) {
            var props = {};
            Object.keys(prop).forEach(function (p) {
                var v = prop[p];
                switch (typeof v) {
                    case 'string':
                    case 'number':
                        props[p + ':' + v] = v;
                        props['reverse:' + v] = p;
                        break;
                    default:
                        if (!Array.isArray(v)) {
                            throw new TypeError(errorPrefix + ' prop value expects string, number or array');
                        }
                        props[p + ':' + v[0]] = v[1];
                        props['reverse:' + v[0]] = p;
                }
            });
            return _.assign({}, family, props);
        });
    });
    return lookup;
}
function findZonesToIgnore(root) {
    var start = null;
    var ranges = [];
    var nexts = [];
    root.walkComments(function (comment) {
        var m = comment.text.match(directivePattern);
        var directive = m && m[1];
        if (!directive) {
            return;
        }
        switch (directive) {
            case 'start-ignore':
                if (start !== null) {
                    throw comment.error('start-ignore already defined', errorContext);
                }
                start = comment.source.end;
                break;
            case 'end-ignore':
                if (start === null) {
                    throw comment.error('start-ignore not defined', errorContext);
                }
                ranges.push({ start: start, end: comment.source.start });
                start = null;
                break;
            case 'ignore-next':
                if (start !== null) {
                    throw comment.error('Unnecessary ignore-next after start-ignore', errorContext);
                }
                nexts.push(comment.source.end);
                break;
            default:
                throw comment.error('Unsupported directive: ' + directive, errorContext);
        }
    });
    return { ranges: ranges, nexts: nexts };
}
module.exports = exports['default'];